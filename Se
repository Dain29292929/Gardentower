local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = workspace
local RunService = game:GetService("RunService")
local Player = Players.LocalPlayer
local place = game.PlaceId
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

-- íŒŒì¼ ê²½ë¡œ ì„¤ì •
local VISITED_SERVERS_FILE = "visited_servers.txt"
local maxVisitedServers = 7

-- íŒŒì¼ ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤ (ìµìŠ¤íí„° í™˜ê²½ìš©)
local function LoadVisitedServers()
    local visitedServers = {}
    if isfile and readfile and isfile(VISITED_SERVERS_FILE) then
        local success, content = pcall(function()
            return readfile(VISITED_SERVERS_FILE)
        end)
        
        if success and content then
            -- ì¤„ë°”ê¿ˆìœ¼ë¡œ ë¶„ë¦¬í•˜ì—¬ JobIdë“¤ì„ ë¡œë“œ
            for jobId in content:gmatch("[^\r\n]+") do
                if jobId and jobId ~= "" then
                    table.insert(visitedServers, jobId)
                end
            end
            print("ğŸ“ íŒŒì¼ì—ì„œ ë°©ë¬¸í•œ ì„œë²„", #visitedServers, "ê°œ ë¡œë“œë¨")
        else
            print("ğŸ“ ë°©ë¬¸í•œ ì„œë²„ íŒŒì¼ ì½ê¸° ì‹¤íŒ¨ ë˜ëŠ” ë¹ˆ íŒŒì¼")
        end
    else
        print("ğŸ“ ë°©ë¬¸í•œ ì„œë²„ íŒŒì¼ì´ ì—†ê±°ë‚˜ íŒŒì¼ ì‹œìŠ¤í…œ í•¨ìˆ˜ ë¯¸ì§€ì›")
    end
    return visitedServers
end

local function SaveVisitedServers(visitedServers)
    if writefile then
        local success, err = pcall(function()
            local content = table.concat(visitedServers, "\n")
            writefile(VISITED_SERVERS_FILE, content)
        end)
        
        if success then
            print("ğŸ’¾ ë°©ë¬¸í•œ ì„œë²„", #visitedServers, "ê°œ íŒŒì¼ì— ì €ì¥ë¨")
        else
            warn("ğŸ’¾ íŒŒì¼ ì €ì¥ ì‹¤íŒ¨:", err)
        end
    else
        warn("ğŸ’¾ writefile í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
    end
end

-- ë°©ë¬¸í•œ ì„œë²„ ëª©ë¡ ë¡œë“œ
local visitedServers = LoadVisitedServers()

-- ë°©ë¬¸í•œ ì„œë²„ ê´€ë¦¬ í•¨ìˆ˜ (ì„±ê³µì‹œì—ë§Œ í˜¸ì¶œë¨)
local function AddVisitedServer(jobId)
    -- ì´ë¯¸ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•˜ê³  ì œê±°
    for i = #visitedServers, 1, -1 do
        if visitedServers[i] == jobId then
            table.remove(visitedServers, i)
            break
        end
    end
    
    -- ë§¨ ì•ì— ì¶”ê°€
    table.insert(visitedServers, 1, jobId)
    
    -- ìµœëŒ€ ê°œìˆ˜ ì´ˆê³¼ì‹œ ì œê±°
    if #visitedServers > maxVisitedServers then
        table.remove(visitedServers) -- ë§ˆì§€ë§‰ ìš”ì†Œ ì œê±°
    end
    
    -- íŒŒì¼ì— ì €ì¥
    SaveVisitedServers(visitedServers)
    
    print("ğŸ“ ì„œë²„ ê¸°ë¡:", jobId, "(ì´", #visitedServers, "ê°œ ì„œë²„ ê¸°ë¡ë¨)")
end

local function IsVisitedServer(jobId)
    for _, id in ipairs(visitedServers) do
        if id == jobId then
            return true
        end
    end
    return false
end

-- Lost Connection ë°©ì§€ (wait ì œê±°)
local function PreventLostConnection()
    TeleportService.TeleportInitFailed:Connect(function(player, teleportResult, errorMessage)
        warn("í…”ë ˆí¬íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨:", teleportResult, errorMessage)
    end)
    game:GetService("GuiService").ErrorMessageChanged:Connect(function() end)
    game:GetService("NetworkClient").ChildRemoved:Connect(function()
        warn("ë„¤íŠ¸ì›Œí¬ ì—°ê²° ëŠì–´ì§ ê°ì§€")
    end)
end
PreventLostConnection()

-- ìºë¦­í„° ì¤€ë¹„ ëŒ€ê¸°
local function WaitForCharacter()
    if not Player.Character or not Player.Character:FindFirstChild("HumanoidRootPart") then
        Player.CharacterAdded:Wait()
        repeat task.wait(0.17) until Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
    end
end

-- ì•ˆì „í•œ ì„œë²„ í˜¸ì¶œ
local function SafeInvoke(funcName, args)
    if type(args) ~= "table" then args = {args} end
    local success, result = pcall(function()
        WaitForCharacter()
        return ReplicatedStorage:WaitForChild("Chest"):WaitForChild("Remotes")
            :WaitForChild("Functions"):WaitForChild(funcName)
            :InvokeServer(unpack(args))
    end)
    if not success then warn("InvokeServer ì˜¤ë¥˜:", funcName, result) end
    return success
end

-- Tashi Blade ì¥ì°©
local function EnsureTashiBlade()
    WaitForCharacter()
    local args = {"Gold Spear"}
    SafeInvoke("InventoryEq", args)
end

-- SeaMonsterSpawnText ì‹œê°„ íŒŒì‹± í•¨ìˆ˜
local function ParseSeaMonsterTime()
    local success, seaMonsterText = pcall(function()
        return ReplicatedStorage:GetAttribute("SeaMonsterSpawnText") or "00:00:00"
    end)
    
    if not success then return 0 end
    
    local hours, minutes, seconds = string.match(seaMonsterText, "(%d+):(%d+):(%d+)")
    if hours and minutes and seconds then
        return tonumber(hours) * 3600 + tonumber(minutes) * 60 + tonumber(seconds)
    end
    return 0
end

-- HydraSeaKing Body ì°¾ê¸° ë° í…”ë ˆí¬íŠ¸
local function TeleportToHydraSeaKingBody()
    WaitForCharacter()
    local hydraBody = Workspace:FindFirstChild("SeaMonster")
        and workspace.SeaMonster:FindFirstChild("HydraSeaKing")
        and Workspace.SeaMonster.HydraSeaKing:FindFirstChild("Body")
    
    if hydraBody then
        local targetPos = hydraBody.Position
        local targetCFrame = hydraBody.CFrame 
        hrp.CFrame = CFrame.lookAt(hrp.Position, targetPos)
        hrp.CFrame = hrp.CFrame + hrp.CFrame.LookVector * 30
        Player.Character.HumanoidRootPart.CFrame = targetCFrame
        SafeInvoke("SkillAction", {"SW_Gold Spear_M1"})
        pcall(function()
            SafeInvoke("SkillAction", {"SW_Gold Spear_Z", {MouseHit = hydraBody.CFrame, Type = "Up"}})
            SafeInvoke("SkillAction", {"SW_Gold Spear_Z", {MouseHit = hydraBody.CFrame, Type = "Down"}})
            SafeInvoke("SkillAction", {"SW_Gold Spear_X", {MouseHit = hydraBody.CFrame, Type = "Up"}})
            SafeInvoke("SkillAction", {"SW_Gold Spear_X", {MouseHit = hydraBody.CFrame, Type = "Down"}})
        end)
        return true
    end
    return false
end

-- ì´ë™ í•¨ìˆ˜ë“¤
local function TeleportToChest()
    WaitForCharacter()
    local island = Workspace:FindFirstChild("Island")
    if island then
        local chestSpawner = island:FindFirstChild("ChestSpawner", true)
        if chestSpawner then
            Player.Character.HumanoidRootPart.CFrame = chestSpawner.CFrame
            return true
        end
    end
    return false
end

local function TeleportToSeaKingBody()
    WaitForCharacter()
    local body = Workspace:FindFirstChild("SeaMonster")
        and Workspace.SeaMonster:FindFirstChild("SeaKing")
        and Workspace.SeaMonster.SeaKing:FindFirstChild("SeaKing")
        and Workspace.SeaMonster.SeaKing.SeaKing:FindFirstChild("Body")
        
    if body then
        local targetCFrame = body.CFrame 
        Player.Character.HumanoidRootPart.CFrame = targetCFrame
        -- model ë³€ìˆ˜ë¥¼ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
        local model = Workspace:FindFirstChild("SeaMonster")
            and Workspace.SeaMonster:FindFirstChild("SeaKing")
            and Workspace.SeaMonster.SeaKing:FindFirstChild("SeaKing")
        
        if model then
            local targetPos = model:GetModelCFrame().Position
            hrp.CFrame = CFrame.lookAt(hrp.Position, targetPos)
            hrp.CFrame = hrp.CFrame + hrp.CFrame.LookVector * 30
        end
        
        SafeInvoke("SkillAction", {"SW_Gold Spear_M1"})
        pcall(function()
            SafeInvoke("SkillAction", {"SW_Gold Spear_Z", {MouseHit = body.CFrame, Type = "Up"}})
            SafeInvoke("SkillAction", {"SW_Gold Spear_Z", {MouseHit = body.CFrame, Type = "Down"}})
            SafeInvoke("SkillAction", {"SW_Gold Spear_X", {MouseHit = body.CFrame, Type = "Up"}})
            SafeInvoke("SkillAction", {"SW_Gold Spear_X", {MouseHit = body.CFrame, Type = "Down"}})
        end)
        return true
    end
    return false
end

local function TeleportToSeaKingWater()
    WaitForCharacter()
    local island = Workspace:FindFirstChild("Island")
    if island then
        local water = island:FindFirstChild("Sea King Water", true)
        if water and water:FindFirstChild("RootPart") then
            Player.Character.HumanoidRootPart.CFrame = water.RootPart.CFrame
            return true
        end
    end
    return false
end

-- ê²Œì„ ì…ì¥
SafeInvoke("EtcFunction", {"EnterTheGame", {}})

-- í…”ë ˆí¬íŠ¸ ì„±ê³µ ê°ì§€ í•¨ìˆ˜
local function DetectTeleportSuccess()
    -- í˜„ì¬ JobIdë¥¼ ê¸°ë¡ (ìƒˆ ì„œë²„ì— ë„ì°©í–ˆì„ ë•Œ ì €ì¥í•˜ê¸° ìœ„í•¨)
    local currentJobId = game.JobId
    
    -- ìŠ¤í¬ë¦½íŠ¸ê°€ ì²˜ìŒ ì‹¤í–‰ë  ë•Œì™€ ìƒˆ ì„œë²„ì— ë„ì°©í–ˆì„ ë•Œë¥¼ êµ¬ë¶„
    -- íŒŒì¼ì—ì„œ ë¡œë“œí•œ ì„œë²„ ëª©ë¡ì— í˜„ì¬ JobIdê°€ ì—†ìœ¼ë©´ ìƒˆ ì„œë²„ì— ì„±ê³µì ìœ¼ë¡œ ì ‘ì†í•œ ê²ƒ
    local isNewServer = not IsVisitedServer(currentJobId)
    
    if isNewServer then
        print("âœ… ìƒˆ ì„œë²„ ì ‘ì† ì„±ê³µ! JobId:", currentJobId)
        AddVisitedServer(currentJobId)
    else
        print("ğŸ”„ ê¸°ì¡´ ì„œë²„ ë˜ëŠ” ì´ë¯¸ ê¸°ë¡ëœ ì„œë²„:", currentJobId)
    end
end

-- ì„œë²„ ì ‘ì† ì„±ê³µ ì‹œ ê¸°ë¡
DetectTeleportSuccess()

-- ìƒíƒœ ì¶”ì  ë³€ìˆ˜ë“¤ (ë””ë²„ê·¸ ë³€ìˆ˜ ì¶”ê°€)
local lastChestTime, lastBodyTime, lastRootTime, lastHydraBodyTime = 0,0,0,0
local serverHopPaused = false
local hydraBodyDisappearedTime = 0
local bodyDisappearedTime = 0
local isWaitingForChestAfterBody = false
local isWaitingForRootAfterHydra = false
local lastDebugTime = 0

-- RunService ì—°ê²° í•´ì œë¥¼ ìœ„í•œ ë³€ìˆ˜
local teleportConnection

-- ì„œë²„í™‰ ì¡°ê±´ í•¨ìˆ˜ (Body ì‚¬ë¼ì§„ í›„ 10ì´ˆ ëŒ€ê¸°)
local function ShouldHopServer()
    WaitForCharacter()
    
    -- SeaMonsterSpawnText ì²´í¬
    local remainingTime = ParseSeaMonsterTime()
    
    -- 59ì´ˆ ì´í•˜ë©´ ì„œë²„í™‰ ì¼ì‹œì •ì§€ (ë‹¨, Body ëŒ€ê¸° ìƒíƒœê°€ ì•„ë‹ ë•Œë§Œ)
    if remainingTime > 0 and remainingTime <= 59 and not isWaitingForChestAfterBody and not isWaitingForRootAfterHydra then
        if not serverHopPaused then
            print("â³ SeaMonster ìŠ¤í°ê¹Œì§€ " .. remainingTime .. "ì´ˆ ë‚¨ìŒ. ì„œë²„í™‰ ì¼ì‹œì •ì§€.")
            serverHopPaused = true
        end
        return false
    end
    
    local island = Workspace:FindFirstChild("Island")
    local chestExists = island and island:FindFirstChild("ChestSpawner", true)
    local waterExists = island and island:FindFirstChild("Sea King Water", true) and island["Sea King Water"]:FindFirstChild("RootPart")
    local bodyExists = Workspace:FindFirstChild("SeaMonster")
        and Workspace.SeaMonster:FindFirstChild("SeaKing")
        and Workspace.SeaMonster.SeaKing:FindFirstChild("SeaKing")
        and Workspace.SeaMonster.SeaKing.SeaKing:FindFirstChild("Body")
    
    -- HydraSeaKing Body ì¡´ì¬ í™•ì¸
    local hydraBodyExists = Workspace:FindFirstChild("SeaMonster")
        and Workspace.SeaMonster:FindFirstChild("HydraSeaKing")
        and Workspace.SeaMonster.HydraSeaKing:FindFirstChild("Body")
    
    local now = tick()

    -- ğŸ” í˜„ì¬ ìƒíƒœ ë””ë²„ê·¸ ì¶œë ¥ (10ì´ˆë§ˆë‹¤)
    if not lastDebugTime or now - lastDebugTime >= 10 then
        print("ğŸ” [DEBUG] í˜„ì¬ ìƒíƒœ:")
        print("  - remainingTime:", remainingTime)
        print("  - serverHopPaused:", serverHopPaused)
        print("  - chestExists:", chestExists and "YES" or "NO")
        print("  - bodyExists:", bodyExists and "YES" or "NO")
        print("  - hydraBodyExists:", hydraBodyExists and "YES" or "NO")
        print("  - waterExists:", waterExists and "YES" or "NO")
        print("  - isWaitingForChestAfterBody:", isWaitingForChestAfterBody and "YES" or "NO")
        print("  - isWaitingForRootAfterHydra:", isWaitingForRootAfterHydra and "YES" or "NO")
        if bodyDisappearedTime > 0 then
            print("  - bodyDisappearedTime ê²½ê³¼:", now - bodyDisappearedTime, "ì´ˆ")
        end
        if hydraBodyDisappearedTime > 0 then
            print("  - hydraBodyDisappearedTime ê²½ê³¼:", now - hydraBodyDisappearedTime, "ì´ˆ")
        end
        lastDebugTime = now
    end

    -- ğŸ”¥ ìš°ì„ ìˆœìœ„ 1: HydraSeaKing Body ëŒ€ê¸° ìƒíƒœ ì²˜ë¦¬ (serverHopPaused ë¬´ì‹œ)
    if isWaitingForRootAfterHydra then
        print("ğŸ [HYDRA WAITING] ëŒ€ê¸° ì¤‘... ê²½ê³¼ì‹œê°„:", hydraBodyDisappearedTime > 0 and (now - hydraBodyDisappearedTime) or 0, "ì´ˆ")
        if hydraBodyDisappearedTime > 0 and now - hydraBodyDisappearedTime >= 10 then
            print("â° [HYDRA HOP] HydraSeaKing Body ì‚¬ë¼ì§„ì§€ 10ì´ˆ ê²½ê³¼, ì„œë²„í™‰ ì‹¤í–‰!")
            hydraBodyDisappearedTime = 0
            lastHydraBodyTime = 0
            isWaitingForRootAfterHydra = false
            serverHopPaused = false  -- ì„œë²„í™‰ ì‹¤í–‰ ì‹œ ì¼ì‹œì •ì§€ í•´ì œ
            return true
        end
        return false
    end

    -- ğŸ”¥ ìš°ì„ ìˆœìœ„ 2: SeaKing Body ëŒ€ê¸° ìƒíƒœ ì²˜ë¦¬ (serverHopPaused ë¬´ì‹œ)
    if isWaitingForChestAfterBody then
        print("ğŸ‘¹ [BODY WAITING] ëŒ€ê¸° ì¤‘... ê²½ê³¼ì‹œê°„:", bodyDisappearedTime > 0 and (now - bodyDisappearedTime) or 0, "ì´ˆ")
        if bodyDisappearedTime > 0 and now - bodyDisappearedTime >= 10 then
            print("â° [BODY HOP] SeaKing Body ì‚¬ë¼ì§„ì§€ 10ì´ˆ ê²½ê³¼, ì„œë²„í™‰ ì‹¤í–‰!")
            bodyDisappearedTime = 0
            lastBodyTime = 0
            isWaitingForChestAfterBody = false
            serverHopPaused = false  -- ì„œë²„í™‰ ì‹¤í–‰ ì‹œ ì¼ì‹œì •ì§€ í•´ì œ
            return true
        end
        return false
    end

    -- HydraSeaKing Body ì²˜ë¦¬
    if hydraBodyExists then
        if lastHydraBodyTime == 0 then
            print("ğŸ [HYDRA FOUND] HydraSeaKing Body ë°œê²¬!")
        end
        lastHydraBodyTime = now
        hydraBodyDisappearedTime = 0
        isWaitingForRootAfterHydra = false
        return false
    elseif lastHydraBodyTime > 0 and hydraBodyDisappearedTime == 0 then
        hydraBodyDisappearedTime = now
        isWaitingForRootAfterHydra = true
        print("ğŸ [HYDRA DISAPPEARED] HydraSeaKing Body ì‚¬ë¼ì§ ê°ì§€! RootPartë¡œ í…”í¬ í›„ 10ì´ˆ í›„ ì„œë²„í™‰ ì˜ˆì •")
        return false
    end

    -- SeaKing Body ì²˜ë¦¬
    if bodyExists then
        if lastBodyTime == 0 then
            print("ğŸ‘¹ [BODY FOUND] SeaKing Body ë°œê²¬!")
        end
        lastBodyTime = now
        bodyDisappearedTime = 0
        isWaitingForChestAfterBody = false
        return false
    elseif lastBodyTime > 0 and bodyDisappearedTime == 0 then
        bodyDisappearedTime = now
        isWaitingForChestAfterBody = true
        print("ğŸ‘¹ [BODY DISAPPEARED] SeaKing Body ì‚¬ë¼ì§ ê°ì§€! Chestë¡œ í…”í¬ í›„ 10ì´ˆ í›„ ì„œë²„í™‰ ì˜ˆì •")
        return false
    end

    -- ì„œë²„í™‰ì´ ì¼ì‹œì •ì§€ëœ ìƒíƒœì´ê³ , Body ê´€ë ¨ ëŒ€ê¸° ìƒíƒœë„ ì•„ë‹ˆë¼ë©´ ì„œë²„í™‰ ì•ˆ í•¨
    if serverHopPaused then
        return false
    end

    -- Chestë§Œ ìˆëŠ” ê²½ìš° (Body ëŒ€ê¸° ìƒíƒœê°€ ì•„ë‹ ë•Œë§Œ)
    if chestExists and not bodyExists and not isWaitingForChestAfterBody then
        if lastChestTime == 0 then 
            print("ğŸ“¦ [CHEST ONLY] Chestë§Œ ì¡´ì¬, 10ì´ˆ íƒ€ì´ë¨¸ ì‹œì‘")
            lastChestTime = now 
        end
        if now - lastChestTime >= 10 then 
            print("ğŸ“¦ [CHEST HOP] Chest 10ì´ˆ ê²½ê³¼, ì„œë²„í™‰ ì‹¤í–‰!")
            lastChestTime = 0 
            return true 
        end
        return false
    elseif not chestExists then
        if lastChestTime > 0 then
            print("ğŸ“¦ [CHEST GONE] Chest ì‚¬ë¼ì§, íƒ€ì´ë¨¸ ë¦¬ì…‹")
        end
        lastChestTime = 0
    end

    -- RootPartë§Œ ìˆëŠ” ê²½ìš° (HydraBody ëŒ€ê¸° ìƒíƒœê°€ ì•„ë‹ ë•Œë§Œ)
    if waterExists and not hydraBodyExists and not isWaitingForRootAfterHydra then
        if lastRootTime == 0 then 
            print("ğŸ’§ [ROOT ONLY] RootPartë§Œ ì¡´ì¬, 10ì´ˆ íƒ€ì´ë¨¸ ì‹œì‘")
            lastRootTime = now 
        end
        if now - lastRootTime >= 10 then 
            print("ğŸ’§ [ROOT HOP] RootPart 10ì´ˆ ê²½ê³¼, ì„œë²„í™‰ ì‹¤í–‰!")
            lastRootTime = 0 
            return true 
        end
        return false
    elseif not waterExists then
        if lastRootTime > 0 then
            print("ğŸ’§ [ROOT GONE] RootPart ì‚¬ë¼ì§, íƒ€ì´ë¨¸ ë¦¬ì…‹")
        end
        lastRootTime = 0
    end

    -- ëª¨ë“  ê²ƒì´ ì—†ìœ¼ë©´ ì¦‰ì‹œ ì„œë²„í™‰
    if not chestExists and not bodyExists and not waterExists and not hydraBodyExists then
        print("ğŸš« [NOTHING] ëª¨ë“  ì˜¤ë¸Œì íŠ¸ ì—†ìŒ, ì¦‰ì‹œ ì„œë²„í™‰!")
        return true
    end

    return false
end

-- ê°œì„ ëœ ì´ë™ ë£¨í”„ (ìš°ì„ ìˆœìœ„ ê¸°ë°˜)
local function UpdatedTeleportLoop()
    if teleportConnection then
        teleportConnection:Disconnect()
    end
    
    teleportConnection = RunService.RenderStepped:Connect(function()
        if TeleportToHydraSeaKingBody() then
            return
        end
        
        if TeleportToSeaKingBody() then
            return
        end
        
        if isWaitingForChestAfterBody and TeleportToChest() then
            return
        end
        
        if isWaitingForRootAfterHydra and TeleportToSeaKingWater() then
            return
        end
        
        if TeleportToChest() then
            return
        end
        
        TeleportToSeaKingWater()
    end)
end

-- ì„œë²„ ëª©ë¡ ê¸°ë°˜ ë¬´í•œ ì„œë²„ í…”ë ˆí¬íŠ¸ (íŒŒì¼ ê¸°ë°˜ ì¤‘ë³µ ë°©ì§€)
local GetServersFunction = ReplicatedStorage:WaitForChild("Chest"):WaitForChild("Remotes")
    :WaitForChild("Functions"):WaitForChild("GetServers")
local currentJobId = game.JobId

print("ğŸ” ì„œë²„ ì¡°ê±´ ê¸°ë°˜ ë¬´í•œ ì„œë²„í™‰ ì‹œì‘ (íŒŒì¼ ê¸°ë°˜ ì¤‘ë³µ ë°©ì§€)")
print("ğŸ“ í˜„ì¬ ë°©ë¬¸í•œ ì„œë²„ ëª©ë¡:", table.concat(visitedServers, ", "))

-- ì´ë™ ë£¨í”„ ì‹œì‘
UpdatedTeleportLoop()

while true do
    if ShouldHopServer() then
        local attemptedJobIds = {}
        local foundValidServer = false
        while not foundValidServer do
            local serversToHopTo = {}
            local foundJobIds = {}
            local success, serversTable = pcall(function()
                return GetServersFunction:InvokeServer()
            end)
            if success and serversTable then
                for _, serverInfo in pairs(serversTable) do
                    local osTime = serverInfo.ServerOsTime
                    local serverJobId = serverInfo.JobId
                    if not osTime or serverJobId == currentJobId or foundJobIds[serverJobId] 
                        or attemptedJobIds[serverJobId] or IsVisitedServer(serverJobId) then 
                        continue 
                    end
                    local uptimeSeconds = os.time() - osTime
                    if uptimeSeconds >= 3600 then
                        local baseTime = math.floor(uptimeSeconds / 3780) * 3780
                        if baseTime > 0 then
                            local minRange = baseTime - 60
                            local maxRange = baseTime + 300
                            if uptimeSeconds >= minRange and uptimeSeconds <= maxRange then
                                table.insert(serversToHopTo, serverInfo)
                                foundJobIds[serverJobId] = true
                            end
                        end
                    end
                end
            end

            if #serversToHopTo > 0 then
                -- ğŸ”½ ì–´ë¦° ì„œë²„ë¶€í„° ì‹œë„
                table.sort(serversToHopTo, function(a, b)
                    return a.ServerOsTime > b.ServerOsTime -- ìµœê·¼ ìƒì„±(ì–´ë¦°) ì„œë²„ê°€ ë¨¼ì €
                end)

                print("ğŸ¯ ì¡°ê±´ ë§ëŠ” ì„œë²„", #serversToHopTo, "ê°œ ë°œê²¬ (íŒŒì¼ ê¸°ë°˜ ì¤‘ë³µ ì œì™¸, ì–´ë¦° ì„œë²„ ìš°ì„ )")
                for _, server in ipairs(serversToHopTo) do
                    print("â¡ï¸ ì„œë²„ í…”ë ˆí¬íŠ¸ ì‹œë„ JobId:", server.JobId, "ì„œë²„ ì‹œì‘ ì‹œê°„:", server.ServerOsTime)
                    attemptedJobIds[server.JobId] = true
                    local tpSuccess, tpErr = pcall(function()
                        TeleportService:TeleportToPlaceInstance(place, server.JobId)
                    end)
                    if tpSuccess then
                        print("âœ… í…”ë ˆí¬íŠ¸ ìš”ì²­ ì„±ê³µ JobId:", server.JobId)
                        print("ğŸ”„ ìƒˆ ì„œë²„ ë¡œë”© ì¤‘... (ì„±ê³µ ì‹œ ìë™ìœ¼ë¡œ íŒŒì¼ì— ì €ì¥ë©ë‹ˆë‹¤)")
                        foundValidServer = true
                    else
                        warn("âŒ í…”ë ˆí¬íŠ¸ ì‹¤íŒ¨ JobId:", server.JobId, tpErr)
                    end
                    task.wait(0.77)
                end
                if foundValidServer then
                    print("ğŸ‰ í˜„ì¬ ë°°ì¹˜ì—ì„œ", #serversToHopTo, "ê°œ ì„œë²„ ëª¨ë‘ ì‹œë„ ì™„ë£Œ!")
                else
                    print("ğŸ”„ í˜„ì¬ ë°°ì¹˜ ì„œë²„ë“¤ ëª¨ë‘ ì‹¤íŒ¨, ìƒˆë¡œìš´ ì„œë²„ ëª©ë¡ ìš”ì²­ì¤‘...")
                    task.wait(0.77)
                end
            else
                print("ğŸ˜¢ ì¡°ê±´ ë§ëŠ” ì„œë²„ ì—†ìŒ (ë˜ëŠ” ëª¨ë‘ ë°©ë¬¸í•¨), ìƒˆë¡œìš´ ì„œë²„ ëª©ë¡ ìš”ì²­ì¤‘...")
                task.wait(0.77)
            end
        end
    end
    task.wait(0.17)
end
